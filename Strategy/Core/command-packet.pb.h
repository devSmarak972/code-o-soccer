// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: command-packet.proto

#ifndef PROTOBUF_INCLUDED_command_2dpacket_2eproto
#define PROTOBUF_INCLUDED_command_2dpacket_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_command_2dpacket_2eproto 

namespace protobuf_command_2dpacket_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_command_2dpacket_2eproto
class StrategyPacket;
class StrategyPacketDefaultTypeInternal;
extern StrategyPacketDefaultTypeInternal _StrategyPacket_default_instance_;
class StrategyPacket_Tactic;
class StrategyPacket_TacticDefaultTypeInternal;
extern StrategyPacket_TacticDefaultTypeInternal _StrategyPacket_Tactic_default_instance_;
namespace google {
namespace protobuf {
template<> ::StrategyPacket* Arena::CreateMaybeMessage<::StrategyPacket>(Arena*);
template<> ::StrategyPacket_Tactic* Arena::CreateMaybeMessage<::StrategyPacket_Tactic>(Arena*);
}  // namespace protobuf
}  // namespace google

enum StrategyPacket_Play {
  StrategyPacket_Play_TestPlay = 0,
  StrategyPacket_Play_SetPosition = 1,
  StrategyPacket_Play_PenaltyOur = 2,
  StrategyPacket_Play_PenaltyOpp = 3,
  StrategyPacket_Play_Stop = 4,
  StrategyPacket_Play_OurGoalKick = 5,
  StrategyPacket_Play_OppGoalKick = 6,
  StrategyPacket_Play_SuperOffense = 7,
  StrategyPacket_Play_Offense1 = 8,
  StrategyPacket_Play_Offense2 = 9,
  StrategyPacket_Play_SuperDefense = 10,
  StrategyPacket_Play_Defense1 = 11,
  StrategyPacket_Play_Defense2 = 12,
  StrategyPacket_Play_PositionOurKickoff = 13,
  StrategyPacket_Play_PositionOppKickoff = 14,
  StrategyPacket_Play_Kickoff = 15,
  StrategyPacket_Play_PositionOurPenalty = 16,
  StrategyPacket_Play_TakeGoalKick = 17,
  StrategyPacket_Play_PositionOurFreeKick = 18,
  StrategyPacket_Play_PositionOppFreeKick = 19,
  StrategyPacket_Play_PositionOurFreeBall = 20,
  StrategyPacket_Play_PositionOppFreeBall = 21,
  StrategyPacket_Play_PositionOppPenalty = 22,
  StrategyPacket_Play_PositionOurGoalKick = 23,
  StrategyPacket_Play_PositionOppGoalKick = 24,
  StrategyPacket_Play_PositionGather = 25,
  StrategyPacket_Play_OppFreeBall = 26,
  StrategyPacket_Play_OurFreeBall = 27,
  StrategyPacket_Play_OppFreeKick = 28,
  StrategyPacket_Play_OurFreeKick = 29,
  StrategyPacket_Play_None = 30
};
bool StrategyPacket_Play_IsValid(int value);
const StrategyPacket_Play StrategyPacket_Play_Play_MIN = StrategyPacket_Play_TestPlay;
const StrategyPacket_Play StrategyPacket_Play_Play_MAX = StrategyPacket_Play_None;
const int StrategyPacket_Play_Play_ARRAYSIZE = StrategyPacket_Play_Play_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrategyPacket_Play_descriptor();
inline const ::std::string& StrategyPacket_Play_Name(StrategyPacket_Play value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrategyPacket_Play_descriptor(), value);
}
inline bool StrategyPacket_Play_Parse(
    const ::std::string& name, StrategyPacket_Play* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrategyPacket_Play>(
    StrategyPacket_Play_descriptor(), name, value);
}
enum StrategyPacket_TacticID {
  StrategyPacket_TacticID_Block = 0,
  StrategyPacket_TacticID_ChargeBall = 1,
  StrategyPacket_TacticID_CoverGoal = 2,
  StrategyPacket_TacticID_DragToGoal = 3,
  StrategyPacket_TacticID_DefendLine = 4,
  StrategyPacket_TacticID_DefendPoint = 5,
  StrategyPacket_TacticID_GoalieOur = 6,
  StrategyPacket_TacticID_GoalieOpp = 7,
  StrategyPacket_TacticID_MarkBot = 8,
  StrategyPacket_TacticID_Pass = 9,
  StrategyPacket_TacticID_Position = 11,
  StrategyPacket_TacticID_PositionForPenalty = 12,
  StrategyPacket_TacticID_PositionForStart = 13,
  StrategyPacket_TacticID_ReceiveBall = 14,
  StrategyPacket_TacticID_Defend = 15,
  StrategyPacket_TacticID_Attack = 16,
  StrategyPacket_TacticID_Steal = 17,
  StrategyPacket_TacticID_Velocity = 19
};
bool StrategyPacket_TacticID_IsValid(int value);
const StrategyPacket_TacticID StrategyPacket_TacticID_TacticID_MIN = StrategyPacket_TacticID_Block;
const StrategyPacket_TacticID StrategyPacket_TacticID_TacticID_MAX = StrategyPacket_TacticID_Velocity;
const int StrategyPacket_TacticID_TacticID_ARRAYSIZE = StrategyPacket_TacticID_TacticID_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrategyPacket_TacticID_descriptor();
inline const ::std::string& StrategyPacket_TacticID_Name(StrategyPacket_TacticID value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrategyPacket_TacticID_descriptor(), value);
}
inline bool StrategyPacket_TacticID_Parse(
    const ::std::string& name, StrategyPacket_TacticID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrategyPacket_TacticID>(
    StrategyPacket_TacticID_descriptor(), name, value);
}
enum StrategyPacket_Which {
  StrategyPacket_Which_PLAY = 1,
  StrategyPacket_Which_TACTIC = 2
};
bool StrategyPacket_Which_IsValid(int value);
const StrategyPacket_Which StrategyPacket_Which_Which_MIN = StrategyPacket_Which_PLAY;
const StrategyPacket_Which StrategyPacket_Which_Which_MAX = StrategyPacket_Which_TACTIC;
const int StrategyPacket_Which_Which_ARRAYSIZE = StrategyPacket_Which_Which_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrategyPacket_Which_descriptor();
inline const ::std::string& StrategyPacket_Which_Name(StrategyPacket_Which value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrategyPacket_Which_descriptor(), value);
}
inline bool StrategyPacket_Which_Parse(
    const ::std::string& name, StrategyPacket_Which* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrategyPacket_Which>(
    StrategyPacket_Which_descriptor(), name, value);
}
// ===================================================================

class StrategyPacket_Tactic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StrategyPacket.Tactic) */ {
 public:
  StrategyPacket_Tactic();
  virtual ~StrategyPacket_Tactic();

  StrategyPacket_Tactic(const StrategyPacket_Tactic& from);

  inline StrategyPacket_Tactic& operator=(const StrategyPacket_Tactic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StrategyPacket_Tactic(StrategyPacket_Tactic&& from) noexcept
    : StrategyPacket_Tactic() {
    *this = ::std::move(from);
  }

  inline StrategyPacket_Tactic& operator=(StrategyPacket_Tactic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyPacket_Tactic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StrategyPacket_Tactic* internal_default_instance() {
    return reinterpret_cast<const StrategyPacket_Tactic*>(
               &_StrategyPacket_Tactic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StrategyPacket_Tactic* other);
  friend void swap(StrategyPacket_Tactic& a, StrategyPacket_Tactic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StrategyPacket_Tactic* New() const final {
    return CreateMaybeMessage<StrategyPacket_Tactic>(NULL);
  }

  StrategyPacket_Tactic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StrategyPacket_Tactic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StrategyPacket_Tactic& from);
  void MergeFrom(const StrategyPacket_Tactic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrategyPacket_Tactic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .StrategyPacket.TacticID tID = 1;
  bool has_tid() const;
  void clear_tid();
  static const int kTIDFieldNumber = 1;
  ::StrategyPacket_TacticID tid() const;
  void set_tid(::StrategyPacket_TacticID value);

  // required int32 botID = 2;
  bool has_botid() const;
  void clear_botid();
  static const int kBotIDFieldNumber = 2;
  ::google::protobuf::int32 botid() const;
  void set_botid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:StrategyPacket.Tactic)
 private:
  void set_has_tid();
  void clear_has_tid();
  void set_has_botid();
  void clear_has_botid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int tid_;
  ::google::protobuf::int32 botid_;
  friend struct ::protobuf_command_2dpacket_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StrategyPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StrategyPacket) */ {
 public:
  StrategyPacket();
  virtual ~StrategyPacket();

  StrategyPacket(const StrategyPacket& from);

  inline StrategyPacket& operator=(const StrategyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StrategyPacket(StrategyPacket&& from) noexcept
    : StrategyPacket() {
    *this = ::std::move(from);
  }

  inline StrategyPacket& operator=(StrategyPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StrategyPacket* internal_default_instance() {
    return reinterpret_cast<const StrategyPacket*>(
               &_StrategyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(StrategyPacket* other);
  friend void swap(StrategyPacket& a, StrategyPacket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StrategyPacket* New() const final {
    return CreateMaybeMessage<StrategyPacket>(NULL);
  }

  StrategyPacket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StrategyPacket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StrategyPacket& from);
  void MergeFrom(const StrategyPacket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrategyPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StrategyPacket_Tactic Tactic;

  typedef StrategyPacket_Play Play;
  static const Play TestPlay =
    StrategyPacket_Play_TestPlay;
  static const Play SetPosition =
    StrategyPacket_Play_SetPosition;
  static const Play PenaltyOur =
    StrategyPacket_Play_PenaltyOur;
  static const Play PenaltyOpp =
    StrategyPacket_Play_PenaltyOpp;
  static const Play Stop =
    StrategyPacket_Play_Stop;
  static const Play OurGoalKick =
    StrategyPacket_Play_OurGoalKick;
  static const Play OppGoalKick =
    StrategyPacket_Play_OppGoalKick;
  static const Play SuperOffense =
    StrategyPacket_Play_SuperOffense;
  static const Play Offense1 =
    StrategyPacket_Play_Offense1;
  static const Play Offense2 =
    StrategyPacket_Play_Offense2;
  static const Play SuperDefense =
    StrategyPacket_Play_SuperDefense;
  static const Play Defense1 =
    StrategyPacket_Play_Defense1;
  static const Play Defense2 =
    StrategyPacket_Play_Defense2;
  static const Play PositionOurKickoff =
    StrategyPacket_Play_PositionOurKickoff;
  static const Play PositionOppKickoff =
    StrategyPacket_Play_PositionOppKickoff;
  static const Play Kickoff =
    StrategyPacket_Play_Kickoff;
  static const Play PositionOurPenalty =
    StrategyPacket_Play_PositionOurPenalty;
  static const Play TakeGoalKick =
    StrategyPacket_Play_TakeGoalKick;
  static const Play PositionOurFreeKick =
    StrategyPacket_Play_PositionOurFreeKick;
  static const Play PositionOppFreeKick =
    StrategyPacket_Play_PositionOppFreeKick;
  static const Play PositionOurFreeBall =
    StrategyPacket_Play_PositionOurFreeBall;
  static const Play PositionOppFreeBall =
    StrategyPacket_Play_PositionOppFreeBall;
  static const Play PositionOppPenalty =
    StrategyPacket_Play_PositionOppPenalty;
  static const Play PositionOurGoalKick =
    StrategyPacket_Play_PositionOurGoalKick;
  static const Play PositionOppGoalKick =
    StrategyPacket_Play_PositionOppGoalKick;
  static const Play PositionGather =
    StrategyPacket_Play_PositionGather;
  static const Play OppFreeBall =
    StrategyPacket_Play_OppFreeBall;
  static const Play OurFreeBall =
    StrategyPacket_Play_OurFreeBall;
  static const Play OppFreeKick =
    StrategyPacket_Play_OppFreeKick;
  static const Play OurFreeKick =
    StrategyPacket_Play_OurFreeKick;
  static const Play None =
    StrategyPacket_Play_None;
  static inline bool Play_IsValid(int value) {
    return StrategyPacket_Play_IsValid(value);
  }
  static const Play Play_MIN =
    StrategyPacket_Play_Play_MIN;
  static const Play Play_MAX =
    StrategyPacket_Play_Play_MAX;
  static const int Play_ARRAYSIZE =
    StrategyPacket_Play_Play_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Play_descriptor() {
    return StrategyPacket_Play_descriptor();
  }
  static inline const ::std::string& Play_Name(Play value) {
    return StrategyPacket_Play_Name(value);
  }
  static inline bool Play_Parse(const ::std::string& name,
      Play* value) {
    return StrategyPacket_Play_Parse(name, value);
  }

  typedef StrategyPacket_TacticID TacticID;
  static const TacticID Block =
    StrategyPacket_TacticID_Block;
  static const TacticID ChargeBall =
    StrategyPacket_TacticID_ChargeBall;
  static const TacticID CoverGoal =
    StrategyPacket_TacticID_CoverGoal;
  static const TacticID DragToGoal =
    StrategyPacket_TacticID_DragToGoal;
  static const TacticID DefendLine =
    StrategyPacket_TacticID_DefendLine;
  static const TacticID DefendPoint =
    StrategyPacket_TacticID_DefendPoint;
  static const TacticID GoalieOur =
    StrategyPacket_TacticID_GoalieOur;
  static const TacticID GoalieOpp =
    StrategyPacket_TacticID_GoalieOpp;
  static const TacticID MarkBot =
    StrategyPacket_TacticID_MarkBot;
  static const TacticID Pass =
    StrategyPacket_TacticID_Pass;
  static const TacticID Position =
    StrategyPacket_TacticID_Position;
  static const TacticID PositionForPenalty =
    StrategyPacket_TacticID_PositionForPenalty;
  static const TacticID PositionForStart =
    StrategyPacket_TacticID_PositionForStart;
  static const TacticID ReceiveBall =
    StrategyPacket_TacticID_ReceiveBall;
  static const TacticID Defend =
    StrategyPacket_TacticID_Defend;
  static const TacticID Attack =
    StrategyPacket_TacticID_Attack;
  static const TacticID Steal =
    StrategyPacket_TacticID_Steal;
  static const TacticID Velocity =
    StrategyPacket_TacticID_Velocity;
  static inline bool TacticID_IsValid(int value) {
    return StrategyPacket_TacticID_IsValid(value);
  }
  static const TacticID TacticID_MIN =
    StrategyPacket_TacticID_TacticID_MIN;
  static const TacticID TacticID_MAX =
    StrategyPacket_TacticID_TacticID_MAX;
  static const int TacticID_ARRAYSIZE =
    StrategyPacket_TacticID_TacticID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TacticID_descriptor() {
    return StrategyPacket_TacticID_descriptor();
  }
  static inline const ::std::string& TacticID_Name(TacticID value) {
    return StrategyPacket_TacticID_Name(value);
  }
  static inline bool TacticID_Parse(const ::std::string& name,
      TacticID* value) {
    return StrategyPacket_TacticID_Parse(name, value);
  }

  typedef StrategyPacket_Which Which;
  static const Which PLAY =
    StrategyPacket_Which_PLAY;
  static const Which TACTIC =
    StrategyPacket_Which_TACTIC;
  static inline bool Which_IsValid(int value) {
    return StrategyPacket_Which_IsValid(value);
  }
  static const Which Which_MIN =
    StrategyPacket_Which_Which_MIN;
  static const Which Which_MAX =
    StrategyPacket_Which_Which_MAX;
  static const int Which_ARRAYSIZE =
    StrategyPacket_Which_Which_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Which_descriptor() {
    return StrategyPacket_Which_descriptor();
  }
  static inline const ::std::string& Which_Name(Which value) {
    return StrategyPacket_Which_Name(value);
  }
  static inline bool Which_Parse(const ::std::string& name,
      Which* value) {
    return StrategyPacket_Which_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .StrategyPacket.Tactic tactic = 2;
  bool has_tactic() const;
  void clear_tactic();
  static const int kTacticFieldNumber = 2;
  private:
  const ::StrategyPacket_Tactic& _internal_tactic() const;
  public:
  const ::StrategyPacket_Tactic& tactic() const;
  ::StrategyPacket_Tactic* release_tactic();
  ::StrategyPacket_Tactic* mutable_tactic();
  void set_allocated_tactic(::StrategyPacket_Tactic* tactic);

  // optional .StrategyPacket.Play play = 1;
  bool has_play() const;
  void clear_play();
  static const int kPlayFieldNumber = 1;
  ::StrategyPacket_Play play() const;
  void set_play(::StrategyPacket_Play value);

  // required .StrategyPacket.Which which = 3;
  bool has_which() const;
  void clear_which();
  static const int kWhichFieldNumber = 3;
  ::StrategyPacket_Which which() const;
  void set_which(::StrategyPacket_Which value);

  // @@protoc_insertion_point(class_scope:StrategyPacket)
 private:
  void set_has_play();
  void clear_has_play();
  void set_has_tactic();
  void clear_has_tactic();
  void set_has_which();
  void clear_has_which();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::StrategyPacket_Tactic* tactic_;
  int play_;
  int which_;
  friend struct ::protobuf_command_2dpacket_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StrategyPacket_Tactic

// required .StrategyPacket.TacticID tID = 1;
inline bool StrategyPacket_Tactic::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrategyPacket_Tactic::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrategyPacket_Tactic::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrategyPacket_Tactic::clear_tid() {
  tid_ = 0;
  clear_has_tid();
}
inline ::StrategyPacket_TacticID StrategyPacket_Tactic::tid() const {
  // @@protoc_insertion_point(field_get:StrategyPacket.Tactic.tID)
  return static_cast< ::StrategyPacket_TacticID >(tid_);
}
inline void StrategyPacket_Tactic::set_tid(::StrategyPacket_TacticID value) {
  assert(::StrategyPacket_TacticID_IsValid(value));
  set_has_tid();
  tid_ = value;
  // @@protoc_insertion_point(field_set:StrategyPacket.Tactic.tID)
}

// required int32 botID = 2;
inline bool StrategyPacket_Tactic::has_botid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrategyPacket_Tactic::set_has_botid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrategyPacket_Tactic::clear_has_botid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrategyPacket_Tactic::clear_botid() {
  botid_ = 0;
  clear_has_botid();
}
inline ::google::protobuf::int32 StrategyPacket_Tactic::botid() const {
  // @@protoc_insertion_point(field_get:StrategyPacket.Tactic.botID)
  return botid_;
}
inline void StrategyPacket_Tactic::set_botid(::google::protobuf::int32 value) {
  set_has_botid();
  botid_ = value;
  // @@protoc_insertion_point(field_set:StrategyPacket.Tactic.botID)
}

// -------------------------------------------------------------------

// StrategyPacket

// optional .StrategyPacket.Play play = 1;
inline bool StrategyPacket::has_play() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrategyPacket::set_has_play() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrategyPacket::clear_has_play() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrategyPacket::clear_play() {
  play_ = 0;
  clear_has_play();
}
inline ::StrategyPacket_Play StrategyPacket::play() const {
  // @@protoc_insertion_point(field_get:StrategyPacket.play)
  return static_cast< ::StrategyPacket_Play >(play_);
}
inline void StrategyPacket::set_play(::StrategyPacket_Play value) {
  assert(::StrategyPacket_Play_IsValid(value));
  set_has_play();
  play_ = value;
  // @@protoc_insertion_point(field_set:StrategyPacket.play)
}

// optional .StrategyPacket.Tactic tactic = 2;
inline bool StrategyPacket::has_tactic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrategyPacket::set_has_tactic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrategyPacket::clear_has_tactic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrategyPacket::clear_tactic() {
  if (tactic_ != NULL) tactic_->Clear();
  clear_has_tactic();
}
inline const ::StrategyPacket_Tactic& StrategyPacket::_internal_tactic() const {
  return *tactic_;
}
inline const ::StrategyPacket_Tactic& StrategyPacket::tactic() const {
  const ::StrategyPacket_Tactic* p = tactic_;
  // @@protoc_insertion_point(field_get:StrategyPacket.tactic)
  return p != NULL ? *p : *reinterpret_cast<const ::StrategyPacket_Tactic*>(
      &::_StrategyPacket_Tactic_default_instance_);
}
inline ::StrategyPacket_Tactic* StrategyPacket::release_tactic() {
  // @@protoc_insertion_point(field_release:StrategyPacket.tactic)
  clear_has_tactic();
  ::StrategyPacket_Tactic* temp = tactic_;
  tactic_ = NULL;
  return temp;
}
inline ::StrategyPacket_Tactic* StrategyPacket::mutable_tactic() {
  set_has_tactic();
  if (tactic_ == NULL) {
    auto* p = CreateMaybeMessage<::StrategyPacket_Tactic>(GetArenaNoVirtual());
    tactic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:StrategyPacket.tactic)
  return tactic_;
}
inline void StrategyPacket::set_allocated_tactic(::StrategyPacket_Tactic* tactic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tactic_;
  }
  if (tactic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tactic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tactic, submessage_arena);
    }
    set_has_tactic();
  } else {
    clear_has_tactic();
  }
  tactic_ = tactic;
  // @@protoc_insertion_point(field_set_allocated:StrategyPacket.tactic)
}

// required .StrategyPacket.Which which = 3;
inline bool StrategyPacket::has_which() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrategyPacket::set_has_which() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrategyPacket::clear_has_which() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrategyPacket::clear_which() {
  which_ = 1;
  clear_has_which();
}
inline ::StrategyPacket_Which StrategyPacket::which() const {
  // @@protoc_insertion_point(field_get:StrategyPacket.which)
  return static_cast< ::StrategyPacket_Which >(which_);
}
inline void StrategyPacket::set_which(::StrategyPacket_Which value) {
  assert(::StrategyPacket_Which_IsValid(value));
  set_has_which();
  which_ = value;
  // @@protoc_insertion_point(field_set:StrategyPacket.which)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::StrategyPacket_Play> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StrategyPacket_Play>() {
  return ::StrategyPacket_Play_descriptor();
}
template <> struct is_proto_enum< ::StrategyPacket_TacticID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StrategyPacket_TacticID>() {
  return ::StrategyPacket_TacticID_descriptor();
}
template <> struct is_proto_enum< ::StrategyPacket_Which> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StrategyPacket_Which>() {
  return ::StrategyPacket_Which_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_command_2dpacket_2eproto
